
Windows operates in two main modes: 


**User-Mode:** 

Most applications & user processes happen here, applications ran within user mode have very limited access to hardware & have to interact with the OS via APIs. These processes are isolated and cannot directly access hardware/critical functions.

Malware is still able to manipulate files, registry, network connections, etc. & may escalate its privilege in order to gain more control. 

-------------------------------------------

**Kernel-Mode:** 

A much more privileged environment where the Windows kernel runs. The kernel has unfettered access to hardware, system resources, and critical functions. It provides core OS services, manages resources, and enforces security & stability. Device drivers also run within it. 

If malware runs within kernel mode, it will gain elevated control & can manipulate system behavior, conceal itself, intercept syscalls, and tamper with security.

-------------------------------------------

**User-Mode Components:** 

Parts of the OS that do not have direct access to hardware/kernel. They interact with system resources through API & syscalls

| **Component**                | **Description**                                                                                                                                                    | **Examples**                                          |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------- |
| **System Support Processes** | Essential components providing crucial functionalities and services for system operation. These are not Windows services but are necessary for system functioning. | winlogon.exe, smss.exe, services.exe                  |
| **Service Processes**        | Processes that host Windows services, running in the background and executing tasks according to their configuration.                                              | Windows Update Service, Task Scheduler, Print Spooler |
| **User Applications**        | Processes created by user programs, interacting with the operating system through APIs, causing transitions between user mode and kernel mode.                     | 32-bit and 64-bit applications                        |
| **Environment Subsystems**   | Components providing execution environments for specific types of applications or processes.                                                                       | Win32 Subsystem, POSIX, OS/2                          |
| **Subsystem DLLs**           | Dynamic-link libraries translating documented functions into internal native system calls, implemented in NTDLL.DLL.                                               | kernelbase.dll, user32.dll, wininet.dll, advapi32.dll |

-------------------------------------------

**Kernel-Mode Components:** 

Parts of the OS that have direct access to hardware and kernel data structures

| **Component**              | **Description**                                                                                                                                              | **Functions**                                                                                           |
|----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------|
| **Executive**              | The upper layer in kernel mode accessed via functions from NTDLL.DLL. It includes components like I/O Manager, Object Manager, Security Reference Monitor, Process Manager, etc. | Manages I/O operations, object management, security, processes; performs checks and delegates operations. |
| **Kernel**                 | Manages system resources and provides low-level services.                                                                                                     | Handles thread scheduling, interrupt and exception dispatching, multiprocessor synchronization.       |
| **Device Drivers**         | Software components that facilitate interaction between the OS and hardware devices.                                                                         | Acts as intermediaries for managing and controlling hardware and software resources.                  |
| **Hardware Abstraction Layer (HAL)** | Provides an abstraction layer between hardware devices and the OS.                                                                                            | Ensures consistent and platform-independent interaction with hardware for software developers.        |
| **Windowing and Graphics System (Win32k.sys)** | Manages the graphical user interface (GUI) and rendering of visual elements on the screen.                                                                 | Handles GUI operations and visual rendering.                                                           |

-------------------------------------------

**Windows API Call Flow:** 

Malware often uses APIs to interact with system resources to carry out operations.

For example: 

Assume a user-mode application tries to access privileged operations and system resources using the `ReadProcessMemory` function (allows a process to read the memory of other processes). 


Call Flow Diagram: `ReadProcessMemory`

![ReadProcessMemory_Call](/Assets/Malware%20Analysis/wininternals_syscall.webp)

Required parameters passed for `ReadProcessMemory`: 

```cmd
BOOL ReadProcessMemory(
  [in]  HANDLE  hProcess,
  [in]  LPCVOID lpBaseAddress,
  [out] LPVOID  lpBuffer,
  [in]  SIZE_T  nSize,
  [out] SIZE_T  *lpNumberOfBytesRead
);

```


`ReadProcessMemory` is a WINAPI function that belongs to the `kernel32.dll` library (the user-mode interface to the WINAPI).

The `kernel32.dll` module interacts with the NTDLL.dll module, which provides a lower-level interface to the Windows kernel

Next the function request is translated to the native API call, which in this case is `NtReadVirtualMemory`

See below for a screenshot from the debugger: 

![x64dbg_readprocessmemory1](/Assets/Malware%20Analysis/x64dbg_readprocessmemory.webp)

The NTDLL.dll module uses syscalls: 

![ntdll](/Assets/Malware%20Analysis/msdn_004_syscall_instruction.webp)

The `syscall` instruction triggers the system call using the parameters set in previous instructions. It transfers control from user-mode to kernel-mode. The kernel will perform the requested operation after validating the parameters and checking the rights of the calling process.

If authorized, the thread transitions to kernel-mode. The kernel maintains a table called System Service Descriptor Table (`SSDT`) or the `Syscall` Table, which contain pointers to various system service routines. These routines handle `syscalls` made by user-mode applications. Each entry corresponds to a specific `syscall` number and the pointer points to the corresponding kernel function that implements the requested operation. 

The `syscall` responsible for `ReadProcessMemory` is executed in the kernel (where Windows manages memory & leverages process isolation mechanisms). The kernel performs validations, access checks, and memory operations to read memory from the target process. The kernel then retrieves the physical memory pages in regard to the requested virtual address and copies that data into the provided buffer. 

When the kernel has finished reading the memory, it transitions the thread back to user-mode and control is returned to the original user-mode application that made the call. The application can now access the data that was read from the target process' memory and continue its execution.

-------------------------------------------

**Portable Executable (PE):** 

Windows uses the PE format to encapsulate executable programs (DLLs & other system components). Fundamentally, it is for Windows to manage executable code and loading it into memory. 

PE files encompass many data types including: 

Executables (`.exe`), dynamic link libraries (`.dll`), kernel modules (`.srv`), control panel applications (`.cpl`), etc. 

PE Sections: 

The PE Structure houses a `Section Table`, that holds sections for distinct purposes. The sections hold the actual content of the file, including the data, resources utilized by the program, and executable code. 

	The .text section is often the subject of examination for potential artifacts related to injection attacks. 

Common PE Sections: 

| Section                             | Description                                                                                                  |
| ----------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| Text Section (.text)                | The hub where the executable code of the program resides.                                                    |
| Data Section (.data)                | A storage for initialized global and static data variables.                                                  |
| Read-only initialized data (.rdata) | Houses read-only data such as constant values, string literals, and initialized global and static variables. |
| Exception information (.pdata)      | A collection of function table entries utilized for exception handling.                                      |
| BSS Section (.bss)                  | Holds uninitialized global and static data variables.                                                        |
| Resource Section (.rsrc)            | Safeguards resources such as images, icons, strings, and version information.                                |
| Import Section (.idata)             | Details about functions imported from other DLLs.                                                            |
| Export Section (.edata)             | Information about functions exported by the executable.                                                      |
| Relocation Section (.reloc)         | Details for relocating the executable's code and data when loaded at a different memory address.             |

	Use PEStudio to delve into the sections of the PE. 

-------------------------------------------

**Processes:** 

An instance of an executing program and its execution in memory. It consists of memory, file handles, threads, and security contexts. 

Each process is characterized by: 

A unique PID (Process Identifier): 

	Assigned to each process within the operating system. This numeric identifier facilitates the tracking and management of the process by the operating system.

Virtual Address Space (VAS): 

	Within Windows, every process is allocated its own virtual address space, offering a virtualized view of the memory for the process. The VAS is sectioned into segments, including code, data, and stack segments, allowing the process isolated 

Executable Code (Image File on Disk): 

	The executable code or the image file, signifies the binary executable file stored on the disk. It houses the instructions and resources necessary for the process to operate.

Table of Handles to System Objects: 

	A reference catalogue for various system objects. System objects can span files, devices, registry keys, synchronization objects, and other resources.

Security Context (Access Token): 

	Each process has a security context associated with it, embodied by an Access Token. This Access Token encapsulates information about the process's security privileges, including the user account under which the process operates and the access rights granted to the process.

One or More Threads Running in its Context: 

	Processes consist of one or more threads, where a thread embodies a unit of execution within the process. Threads enable concurrent execution within the process and facilitate multitasking.

-----------------------------------------

**Dynamic-link library (DLL):** 

A type of PE that acts as a shared library that can be used by more than one program at a time. They contain a ton of functions that can be exploited by malware. 

Import Functions: 

Functionalities that a binary dynamically links to from external libraries/modules during runtime. 

	Examining import functions can show what libraries, APIs, the malware is dependent on/interacts with. It can also show what files, registry objects, and processes it uses. 

	Seeing what functions are imported will show us what the malware can do i.e. file operations, networking, manipulating the registry, etc. 

	Identifying import function names can serve as IOCs for mitigation. 




