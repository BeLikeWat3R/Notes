
With no source code, analysts are forced to disassemble binaries & look at their assembly code to ascertain what they do & how they work. 

To do  disassemblers and debuggers are employed: 

**Disassembler**: 

A tool that is used to step through the code without executing it. This allows for gaining an understanding of the logic & structure of the code without running it. Examples are `IDA, Cutter, and Ghidra`

**Debugger**:

Like a disassembler, they disassemble binaries into their assembly instructions. It also allows use to execute code in a controlled environment - going by instruction to instruction, skipping to specific lines, or halting flow by using breakpoints. Examples are `OllyDbg, x32dbg, x64dbg, and IDA`

**Code Analysis:** 

The process of investigating & deciphering the behavior & functionality of a compiled binary/program. This involves analyzing instructions, control flow, and data structures within the code to determine the sample's function, purpose, and to derive IOCs.

**Disassembly:** 

Allows for an understanding by reversing the compilation process. When machine code is converted back into Assembly - we end up with instructions that are symbolic & mnemonic, allowing us to determine the logic & structure of the program.

The process is below for brevity: 

![disassemblydiagram](/Assets/Malware%20Analysis/disassembly.webp)

-----------------------------------------

## **Sample Analysis With IDA:** 

In order to load a sample into IDA, click on the 'new' button & select the sample. 

Once the file format is determined by IDA, the sample will be disassemble the sample into Assembly

Below are the different views within IDA: 

![IDAViews](/Assets/Malware%20Analysis/ida_intro_views.webp)


Text & Graph Views: 

The **Graph View** depicts the instructions as a graphic illustration of the function's basic blocks and interconnections. It offers a better identification of execution flow, helps identify loops, conditionals, jumps, and just an overall better understanding of how the sample branches/cycles through different sections of code. 

Functions are displayed as nodes, each function is depicted as a distinct node with a unique identifier and other details such as: function name, address, and size

![IDAGraph](/Assets/Malware%20Analysis/ida_graph_view.webp)

The **Text View** displays the assembly instructions along with their corresponding address in memory. Each line of the text view represents an instruction or data element in the code like `section name:virtual address` 

![idatext](/Assets/Malware%20Analysis/ida_text_view.webp)

**Solid Arrow (â†’):** 

Denotes a direct jump/branch instruction, indicating an unconditional shift in the flow where execution moves from one location to another. Look for `jmp` and `call` 

**Dashed Arrow (-->):** 

Denotes a conditional jump or branch instruction, suggesting that the flow might change based on a specific condition. The destination of the jump depends on the condition's outcome. For example a `jz` instruction will only jump if a previous comparison yielded a value of zero. 

![idaarrows](/Assets/Malware%20Analysis/ida_text_view_arrows.webp)


**Recognizing the Main Function:** 

Look for function calls or jumps to other functions, because one of them is likely to be the `main` function. IDAs Graph View, cross-references, and function list are really great for this.

The following screenshot shows the `start` function, which is our sample's entry point & is responsible for initializing the runtime environment before invoking the true `main` function. 

![idastart](/Assets/Malware%20Analysis/ida__001_start.webp)

IDA shows the function at the beginning by default, even if it isn't the `main` function

Before we find the main function, it is necessary to ascertain the the function of the `start` function. The `start` function contains some initialization code (as stated above), function calls, and exception handling. 

It eventually jumps to `loc_40150C` which is an exception handler. Thus, we can determine that this function is in fact not the `main` function.

The code begins by subtracting `0x28` from `rsp` (stack pointer), creating space on the stack for local variables and preserving previous stack contents. 

`loc_401F4` shows exception handling. The `__try` & `__except` suggest the setup of this. Notice the `call` to two subroutines `sub_401650` & `sub_401180` respectively. The names are generated by IDA to denote subroutines, program locations, and data. These auto-generated names usually have one of the following prefixes: `sub_virtual_address` or `loc_virtual_address`


**Navigating Through Functions:** 

Let's check out those two `sub_` functions we were just referring to:

Right click & select 'Jump to Operand' (or hit 'Enter'), this will take us to the beginning of the called function or the destination of the jump

![idainitial](/Assets/Malware%20Analysis/ida__002_initial_stack.webp)


Within `sub_401650` we can see call instructions to functions like: `GetSystemTime`, `GetCurrentProcessID`, etc. This is normal to see at the beginning of disassembled code & usually is related to setting up the initial stack frame & carrying out some system related startup tasks. 

This is not our `main` function. 

Let's jump to the other, `sub_` function and take a look at it, in order to return to a function you were previously analyzing hit ESC or click the 'back arrow' on the toolbar. 

Now we're looking at `sub_401180` 

![idasub_2](/Assets/Malware%20Analysis/ida__003_startupinfo.webp)


This function also appears to be related to `StartupInfo` and performs checks relative to its value. The `rep stosq`  instruction is related to memory, while further instructions modify registers and execute conditional jumps based on the register value. 

Scroll all the way to the endpoint of the function, and start scrolling up - see if there are any interesting calls. 
 
![idaint](/Assets/Malware%20Analysis/ida_004_intmain.webp)

Jump to `sub_403250` 

![idamainfunc](/Assets/Malware%20Analysis/ida_005_main.webp)

It appears that this function is querying the registry for a value associated with the `SOFTWARE\\VMWare, Inc.\\VMWare Tools` path and is performing a comparison to determine if VMWare Tools is installed on the box. 

This is most likely our `main` function.

We can see that the registry query is performed using the function `RegOpenKeyExA` as seen in the instruction `call cs:RegOpenKeyExA`

`RegOpenKeyExA` is a function part of the Windows Registry API and is used to open a handle to a specified registry key. Simply put, it allows for access to the Registry. The `A` in the function signifies it is the ANSI version. 

In IDA,  `cs` is a segment register that usually refers to the code segment. If we jump to the `call cs:RegOpenKeyExA` we will see that it brings is to the `.idata` section, which includes import data and the import address of the function. 

![idaapi](/Assets/Malware%20Analysis/ida_winapi.webp)

This not the actual address of the function, but the address in the IAT (Import Address Table). This table houses the address that will be dynamically resolved at runtime to point to the actual function implementation in the respective DLL. In this case, according to research: the DLL is `advapi32.dll` 

`extrn RegOpenKeyExA:qword` indicates that the function is an external symbol to be resolved at runtime. This tells the assembler that the function is defined in a different module/library and the linker will handle the resolution of its address during linking. 

In actuality `cs:RegOpenKeyExA` is a means to access the IAT entry for the function in the code using a relative reference. The true address will be resolved & stored in the IAT during runtime by the OS' dynamic linker/loader. 

Because this is most likely the `main` function, let's rename it by right clicking the function name and clicking rename. This will update the function name throughout the disassembly and any references within the sample. 

Let's check out the other two function calls prior to calling `RegOpenKeyExA`, `sub_401610` and `sub_`

