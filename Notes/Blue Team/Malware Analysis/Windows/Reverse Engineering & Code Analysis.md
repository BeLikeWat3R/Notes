
With no source code, analysts are forced to disassemble binaries & look at their assembly code to ascertain what they do & how they work. 

To do  disassemblers and debuggers are employed: 

**Disassembler**: 

A tool that is used to step through the code without executing it. This allows for gaining an understanding of the logic & structure of the code without running it. Examples are `IDA, Cutter, and Ghidra`

**Debugger**:

Like a disassembler, they disassemble binaries into their assembly instructions. It also allows use to execute code in a controlled environment - going by instruction to instruction, skipping to specific lines, or halting flow by using breakpoints. Examples are `OllyDbg, x32dbg, x64dbg, and IDA`

**Code Analysis:** 

The process of investigating & deciphering the behavior & functionality of a compiled binary/program. This involves analyzing instructions, control flow, and data structures within the code to determine the sample's function, purpose, and to derive IOCs.

**Disassembly:** 

Allows for an understanding by reversing the compilation process. When machine code is converted back into Assembly - we end up with instructions that are symbolic & mnemonic, allowing us to determine the logic & structure of the program.

The process is below for brevity: 

![disassemblydiagram](/Assets/Malware%20Analysis/disassembly.webp)

-----------------------------------------

## **Sample Analysis With IDA:** 

In order to load a sample into IDA, click on the 'new' button & select the sample. 

Once the file format is determined by IDA, the sample will be disassemble the sample into Assembly

Below are the different views within IDA: 

![IDAViews](/Assets/Malware%20Analysis/ida_intro_views.webp)


Text & Graph Views: 

The **Graph View** depicts the instructions as a graphic illustration of the function's basic blocks and interconnections. It offers a better identification of execution flow, helps identify loops, conditionals, jumps, and just an overall better understanding of how the sample branches/cycles through different sections of code. 

Functions are displayed as nodes, each function is depicted as a distinct node with a unique identifier and other details such as: function name, address, and size

![IDAGraph](/Assets/Malware%20Analysis/ida_graph_view.webp)

The **Text View** displays the assembly instructions along with their corresponding address in memory. Each line of the text view represents an instruction or data element in the code like `section name:virtual address` 

![idatext](/Assets/Malware%20Analysis/ida_text_view.webp)

**Solid Arrow (â†’):** 

Denotes a direct jump/branch instruction, indicating an unconditional shift in the flow where execution moves from one location to another. Look for `jmp` and `call` 

**Dashed Arrow (-->):** 

Denotes a conditional jump or branch instruction, suggesting that the flow might change based on a specific condition. The destination of the jump depends on the condition's outcome. For example a `jz` instruction will only jump if a previous comparison yielded a value of zero. 

![idaarrows](/Assets/Malware%20Analysis/ida_text_view_arrows.webp)


**Recognizing the Main Function:** 

Look for function calls or jumps to other functions, because one of them is likely to be the `main` function. IDAs Graph View, cross-references, and function list are really great for this.

The following screenshot shows the `start` function, which is our sample's entry point & is responsible for initializing the runtime environment before invoking the true `main` function. 

![idastart](/Assets/Malware%20Analysis/ida__001_start.webp)

IDA shows the function at the beginning by default, even if it isn't the `main` function

Before we find the main function, it is necessary to ascertain the the function of the `start` function. The `start` function contains some initialization code (as stated above), function calls, and exception handling. 

It eventually jumps to `loc_40150C` which is an exception handler. Thus, we can determine that this function is in fact not the `main` function.

The code begins by subtracting `0x28` from `rsp` (stack pointer), creating space on the stack for local variables and preserving previous stack contents. 

`loc_401F4` shows exception handling. The `__try` & `__except` suggest the setup of this. Notice the `call` to two subroutines `sub_401650` & `sub_401180` respectively. The names are generated by IDA to denote subroutines, program locations, and data. These auto-generated names usually have one of the following prefixes: `sub_virtual_address` or `loc_virtual_address`


**Navigating Through Functions:** 

Let's check out those two `sub_` functions we were just referring to:

Right click & select 'Jump to Operand', this will take us to the beginning of the called function or the destination of the jump

![idainitial](/Assets/Malware%20Analysis/ida__002_initial_stack.webp)


Within `sub_401650` we can see call instructions to functions like: `GetSystemTime`, `GetCurrentProcessID`, etc. This is normal to see at the beginning of disassembled code & usually is related to setting up the initial stack frame & carrying out some system related startup tasks. 

This is not our `main` function. 

Let's jump to the other, `sub_` function and take a look at it, in order to return to a function you were previously analyzing hit ESC or click the 'back arrow' on the toolbar. 

Now we're looking at `sub_401180` 

![idasub2](/Assets/MAlware%20Analysis/ida__003_startupinfo.webp)


This function also appears to be related to `StartupInfo` and performs checks relative to its value. 
 
