
With no source code, analysts are forced to disassemble binaries & look at their assembly code to ascertain what they do & how they work. 

To do  disassemblers and debuggers are employed: 

**Disassembler**: 

A tool that is used to step through the code without executing it. This allows for gaining an understanding of the logic & structure of the code without running it. Examples are `IDA, Cutter, and Ghidra`

**Debugger**:

Like a disassembler, they disassemble binaries into their assembly instructions. It also allows use to execute code in a controlled environment - going by instruction to instruction, skipping to specific lines, or halting flow by using breakpoints. Examples are `OllyDbg, x32dbg, x64dbg, and IDA`

**Code Analysis:** 

The process of investigating & deciphering the behavior & functionality of a compiled binary/program. This involves analyzing instructions, control flow, and data structures within the code to determine the sample's function, purpose, and to derive IOCs.

**Disassembly:** 

Allows for an understanding by reversing the compilation process. When machine code is converted back into Assembly - we end up with instructions that are symbolic & mnemonic, allowing us to determine the logic & structure of the program.

The process is below for brevity: 

![disassemblydiagram](/Assets/Malware%20Analysis/disassembly.webp)

-----------------------------------------

IDA: 

In order to load a sample into IDA, click on the 'new' button & select the sample. 

Once the file format is determined by IDA, the sample will be disassemble the sample into Assembly

Below are the different views within IDA: 

![IDAViews](/Assets/Malware%20Analysis/ida_intro_views.webp)


Text & Graph Views: 

The **Graph View** depicts the instructions as a graphic illustration of the function's basic blocks and interconnections. It offers a better identification of execution flow, helps identify loops, conditionals, jumps, and just an overall better understanding of how the sample branches/cycles through different sections of code. 

Functions are displayed as nodes, each function is depicted as a distinct node with a unique identifier and other details such as: function name, address, and size

![IDAGraph](/Assets/Malware%20Analysis/ida_graph_view.webp)

The **Text View** displays the assembly instructions along with their corresponding address in memory. Each line of the text view represents an instruction or data element in the code like `section name:virtual address` 

![idatext](/Assets/Malware%20Analysis/ida_text_view.webp)

**Solid Arrow (â†’):** 

Denotes a direct jump/branch instruction, indicating an unconditional shift in the flow where execution moves from one location to another. Look for `jmp` and `call` 

**Dashed Arrow:** 

Denotes a conditional jump or branch instruction, suggesting that the flow might change based on a specific condition. The destination of the jump depends on the condition's outcome. For example a `jz` instruction will only jump if a previous comparison yielded a value of zero. 

![idaarrows](/Assets/Malware%20Analysis/ida_text_view_arrows.webp)

