
With no source code, analysts are forced to disassemble binaries & look at their assembly code to ascertain what they do & how they work. 

To do  disassemblers and debuggers are employed: 

**Disassembler**: 

A tool that is used to step through the code without executing it. This allows for gaining an understanding of the logic & structure of the code without running it. Examples are `IDA, Cutter, and Ghidra`

**Debugger**:

Like a disassembler, they disassemble binaries into their assembly instructions. It also allows use to execute code in a controlled environment - going by instruction to instruction, skipping to specific lines, or halting flow by using breakpoints. Examples are `OllyDbg, x32dbg, x64dbg, and IDA`

**Code Analysis:** 

The process of investigating & deciphering the behavior & functionality of a compiled binary/program. This involves analyzing instructions, control flow, and data structures within the code to determine the sample's function, purpose, and to derive IOCs.

**Disassembly:** 

Allows for an understanding by reversing the compilation process. When machine code is converted back into Assembly - we end up with instructions that are symbolic & mnemonic, allowing us to determine the logic & structure of the program.

The process is below for brevity: 

![disassemblydiagram](/Assets/Malware%20Analysis/disassembly.webp)

-----------------------------------------

## **Sample Analysis With IDA:** 

In order to load a sample into IDA, click on the 'new' button & select the sample. 

Once the file format is determined by IDA, the sample will be disassemble the sample into Assembly

*We will be conducting analysis from start to finish on shell.exe

Below are the different views within IDA: 

![IDAViews](/Assets/Malware%20Analysis/ida_intro_views.webp)


**Text & Graph Views:** 

The **Graph View** depicts the instructions as a graphic illustration of the function's basic blocks and interconnections. It offers a better identification of execution flow, helps identify loops, conditionals, jumps, and just an overall better understanding of how the sample branches/cycles through different sections of code. 

Functions are displayed as nodes, each function is depicted as a distinct node with a unique identifier and other details such as: function name, address, and size

![IDAGraph](/Assets/Malware%20Analysis/ida_graph_view.webp)

The **Text View** displays the assembly instructions along with their corresponding address in memory. Each line of the text view represents an instruction or data element in the code like `section name:virtual address` 

![idatext](/Assets/Malware%20Analysis/ida_text_view.webp)

**Solid Arrow (â†’):** 

Denotes a direct jump/branch instruction, indicating an unconditional shift in the flow where execution moves from one location to another. Look for `jmp` and `call` 

**Dashed Arrow (-->):** 

Denotes a conditional jump or branch instruction, suggesting that the flow might change based on a specific condition. The destination of the jump depends on the condition's outcome. For example a `jz` instruction will only jump if a previous comparison yielded a value of zero. 

![idaarrows](/Assets/Malware%20Analysis/ida_text_view_arrows.webp)


**Recognizing the Main Function:** 

Look for function calls or jumps to other functions, because one of them is likely to be the `main` function. IDAs Graph View, cross-references, and function list are really great for this.

The following screenshot shows the `start` function, which is our sample's entry point & is responsible for initializing the runtime environment before invoking the true `main` function. 

![idastart](/Assets/Malware%20Analysis/ida__001_start.webp)

IDA shows the function at the beginning by default, even if it isn't the `main` function

Before we find the main function, it is necessary to ascertain the the function of the `start` function. The `start` function contains some initialization code (as stated above), function calls, and exception handling. 

It eventually jumps to `loc_40150C` which is an exception handler. Thus, we can determine that this function is in fact not the `main` function.

The code begins by subtracting `0x28` from `rsp` (stack pointer), creating space on the stack for local variables and preserving previous stack contents. 

`loc_401F4` shows exception handling. The `__try` & `__except` suggest the setup of this. Notice the `call` to two subroutines `sub_401650` & `sub_401180` respectively. The names are generated by IDA to denote subroutines, program locations, and data. These auto-generated names usually have one of the following prefixes: `sub_virtual_address` or `loc_virtual_address`


**Navigating Through Functions:** 

Let's check out those two `sub_` functions we were just referring to:

Right click & select 'Jump to Operand' (or hit 'Enter'), this will take us to the beginning of the called function or the destination of the jump

![idainitial](/Assets/Malware%20Analysis/ida__002_initial_stack.webp)


Within `sub_401650` we can see call instructions to functions like: `GetSystemTime`, `GetCurrentProcessID`, etc. This is normal to see at the beginning of disassembled code & usually is related to setting up the initial stack frame & carrying out some system related startup tasks. 

This is not our `main` function. 

Let's jump to the other, `sub_` function and take a look at it, in order to return to a function you were previously analyzing hit ESC or click the 'back arrow' on the toolbar. 

Now we're looking at `sub_401180`:

![idasub_2](/Assets/Malware%20Analysis/ida__003_startupinfo.webp)


This function also appears to be related to `StartupInfo` and performs checks relative to its value. The `rep stosq`  instruction is related to memory, while further instructions modify registers and execute conditional jumps based on the register value. 

Scroll all the way to the endpoint of the function, and start scrolling up - see if there are any interesting calls. 
 
![idaint](/Assets/Malware%20Analysis/ida_004_intmain.webp)

Jump to `sub_403250` 

![idamainfunc](/Assets/Malware%20Analysis/ida_005_main.webp)

It appears that this function is querying the registry for a value associated with the `SOFTWARE\\VMWare, Inc.\\VMWare Tools` path and is performing a comparison to determine if VMWare Tools is installed on the box. 

This is most likely our `main` function.

We can see that the registry query is performed using the function `RegOpenKeyExA` as seen in the instruction `call cs:RegOpenKeyExA`

`RegOpenKeyExA` is a function part of the Windows Registry API and is used to open a handle to a specified registry key. Simply put, it allows for access to the Registry. The `A` in the function signifies it is the ANSI version. 

In IDA,  `cs` is a segment register that usually refers to the code segment. If we jump to the `call cs:RegOpenKeyExA` we will see that it brings is to the `.idata` section, which includes import data and the import address of the function. 

![idaapi](/Assets/Malware%20Analysis/ida_winapi.webp)

This not the actual address of the function, but the address in the IAT (Import Address Table). This table houses the address that will be dynamically resolved at runtime to point to the actual function implementation in the respective DLL. In this case, according to research: the DLL is `advapi32.dll` 

`extrn RegOpenKeyExA:qword` indicates that the function is an external symbol to be resolved at runtime. This tells the assembler that the function is defined in a different module/library and the linker will handle the resolution of its address during linking. 

In actuality `cs:RegOpenKeyExA` is a means to access the IAT entry for the function in the code using a relative reference. The true address will be resolved & stored in the IAT during runtime by the OS' dynamic linker/loader. 

Because this is most likely the `main` function, let's rename it by right clicking the function name and clicking rename. This will update the function name throughout the disassembly and any references within the sample. 

Let's check out the other two function calls prior to calling `RegOpenKeyExA`, `sub_401610` and `sub_403110`:

![idainit](/Assets/Malware%20Analysis/ida_007_init_checks.webp)

`sub_401610` examines the value of the variable `cs:dword:408030`, if the value is 0 - it becomes 1. It then redirects to `sub_4015A0`

To break it down further, the subroutine transfers the value of the variable `dword_408030` into `eax`. Next it conducts a bitwise AND operation (with `test`)  with `eax` and itself to determine whether its value is 0 or not. If the result is 0, it jumps to `sub_4015A0` 

The code for the subdirectory is below: 

```nasm
sub_4015A0 proc near

push    rsi
push    rbx
sub     rsp, 28h
mov     rdx, cs:off_405730
mov     rax, [rdx]
mov     ecx, eax
cmp     eax, 0FFFFFFFFh
jz      short loc_4015F0
```

The function pushes the values of `rsi` & `rbx` onto the stack, preserving the register values. It allots space on the stack by subtracting 28h (40) bytes from `rsp`. It then retrieves a function pointer from the address encapsulated in `off_405730` and puts it in `rax`. 

These seem to be initialization checks related to function pointers before the program calls the next subroutine (`sub_403110`) & the WINAPI function for registry operations. This is not the `main` function. Rename the function to remember this. 

Next is `sub_403110`:

![ida_shell](/Assets/Malware%20Analysis/ida_008_shellexecutea.webp)

The variables `Parameters`, `File`, and `Operation` are string variables within the `.rdata` section of the executable. The `lea` instructions are used to obtain the memory addresses of these strings which are passed as arguments to the `ShellExecuteA` function. This block of code pings 5 times and then reverts to the preceding function. 

Let's go back to `RegOpenKeyExA`, to avoid posting another screenshot - here is the code & comments denoting each instruction's funtion

```nasm
lea     rax, [rsp+148h+hKey]      ; Calculate the address of hKey
xor     r8d, r8d                  ; Clear r8d register (ulOptions)
mov     [rsp+148h+phkResult], rax ; Store the calculated address of hKey in phkResult
mov     r9d, 20019h               ; Set samDesired to 0x20019h (which is KEY_READ in MS-DOCS)
lea     rdx, aSoftwareVmware      ; Load address of string "SOFTWARE\\VMware, Inc.\\VMware Tools"
mov     rcx, 0FFFFFFFF80000002h   ; Set hKey to 0xFFFFFFFF80000002h (HKEY_LOCAL_MACHINE)
call    cs:RegOpenKeyExA          ; Call the RegOpenKeyExA function
test    eax, eax                  ; Check the return value
jnz     short loc_40330F          ; Jump if the return value is not zero (error condition)
```


Always reference Microsoft documentation when WINAPI functions are found to understand its syntax, parameters, and return value. This will make it easier to understand probable values within the registers when these functions are called. 

A little further down, we see another WINAPI function, `RegQueryValueExA`. 

![idasandbox](/Assets/Malware%20Analysis/ida_009_after_sandbox.webp)

This function retrieves the type & data for the specified value name associated with an open registry key. This key data is compared and when matched, displays a message box stating "Sandbox Detected". If it doesn't match, it redirects to another subroutine, `sub_402EA0` 

![idaddr](/Assets/Malware%20Analysis/ida_010_getaddrinfo.webp)

This subroutine seems to execute network operations utilizing the Windows Socket API (Winsock). It calls the `WSAStartup` function to setup the Winsock library, then it calls the Winsock API `getaddrinfo` which pulls address information for the specified node `pNodeName` based on the hints provided `pHints`. The subroutine verifies the address as resolved using  `getaddrinfo` 

If `getaddrinfo` returns a 0, this implies that the address has been resolved to an IP address. Next, if successful, there is a jump to a message box which displays Sandbox Detected, if not it directs to `sub_402D00`

Next it calls `WSACleanup`,  cleaning resources regarding Winsock if the address resolution succeeded or not. 

Take note of the string `iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com` and note it as a possible IOC. 

Next is looking at `sub_402D00`:

![idacheck](/Assets/Malware%20Analysis/ida_011_func_check.webp)

This function first reserves space on the stack for local variables before calling `sub_402C20`, the output is stored within `eax`. Depending on the results, it either returns `retn` or jumps to `sub_402D20`.

Now we'll examine `sub_402C20`:

![idasocket](/Assets/Malware%20Analysis/ida_012_socketconnect.webp)

The function calls the Winsock library, generates a socket, and connects to `45.33.32.156` over port `1337` (7A69 in hex). It evaluates the return value (`eax`) to determine if the connection was successful. However at the end of the function the instruction `inc eax` increments `eax` by 1. After this, the code looks at the value of `eax` using the `jnz` instruction. 

If the connection fails, the function should return -1, per Windows documentation. Because `eax` is incremented by 1, this should be 0. If so, the message box will print "Sandbox Detected". This suggests that the function is determining the state of the internet connection. 

In the inverse, if the connection is successful, a non-zero value will be returned - telling the code to jump to `loc_402CD0` 

Note `45.33.32.156` as a potential IOC. 

Now for `sub_402F40`:

![ida_svchost](/Assets/Malware%20Analysis/ida_015_svchost.webp)

The function calls `getenv` with `rcx` passing the argument for `TEMP` and saves the results in `eax`, retrieving the `TEMP` environment variable's value.   

To get the environment variable for `TEMP` We can use PowerShell to print it: 

```powershell
Get-ChildItem env:TEMP
```

Next it calls the `sprintf` function to append the obtained `TEMP` path to the string `svchost.exe` to get a complete file path. `GetComputerNameA` is called to retrieve the hostname & save to a buffer. 

If the hostname doesn't exist, it branches to  `loc_d030F8` which holds instructions for returning. 

If the hostname exists (non-zero), the code jumps to instruction on the last side of the following screenshot: 

![ida_download](/Assets/Malware%20Analysis/ida_016_svchost_download.webp)

We can see `sub_403220` is called: 

The function formats a string containing a user-agent value with the string `Windows-"Update/7.6.7600.256 %s"`(The `%`s is a placeholder for the previous obtained hostname, which is delivered to this function via `rcx`) 

So the complete value reads `Windows-Update/7.6.7600.256 [HOSTNAME]` since `GetComputerNameA` grabbed the hostname beforehand. 

In the previous function, `InternetOpenA` (WINAPI function) is called to commence a web session & configure parameters for `InternetOpenUrlA`, which opens the URL `http://ms-windows-update.com/svchost.exe`

Note the URL as a possible IOC, the sample is downloading an additional executable from that address. 

If the URL is opened, the code branches to `loc_40301E`:

![idafile](/Assets/Malware%20Analysis/ida_017_createfile.webp)

The WINAPI function `CreateFileA` is called, which is used to generate a file on the box, specifying the prior file path. 

The code then loops and calls `InternetReadFile` to pull data from the URL specified above. If successful, the code jumps and calls `WriteFile` to write the data to `svchost.exe` within the `TEMP` directory.

![idaloop](/Assets/Malware%20Analysis/ida_018_readfile.webp)

After writing the data, the code loops to read more data until `InternetReadFile` returns a value that determines the end of the data stream. Once all data has been read & written, the opened file and the internet handles are closed using `CloseHandle` & `InternetCloseHandles` respectively. 

The code then leaps to `loc_4030D3` where it calls `sub_403190`:

![idareg](/Assets/Malware%20Analysis/ida_19_reg.webp)

The function has various WINAPI calls that modify the registry, like `RegOpenKeyExA` & `RegSetValueExA`

It appears that the function places the file `svchost.exe` into the registry path `SOFTWARE\Microsoft\Windows\CurrentVersion\Run` with the value `WindowsUpdater` and closes the registry key. 

Note down the registry path and value name above as possible IOCs as this is the sample establishing persistence. 

Next it calls `sub_403150` which funnels an argument into `svchost.exe`. Research suggests the argument (`1Lbcfr7sAHTD9CgdQo3HTMTkV8LK4ZnX71`) could be a wallet address of some kind. 

Retracing our steps we still haven't scrutinized `sub_402D20`:

![idanote](/Assets/Malware%20Analysis/ida_022_notepad.webp)










