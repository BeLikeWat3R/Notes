
Debugging adds a dynamic & interactive element to analyzing code allowing for real time behavioral analysis. 

Analyzing code & debugging together allows for comprehensive understanding of the sample. 

We will use x64dbg for debugging in this example with shell.exe

Below we can see the default views & the first breakpoint (at the beginning of the code) for the sample. 

![x64dbgview](/Assets/Malware%20Analysis/x64dbg_001_views.webp)

-----------------------------------------

**Simulating Connectivity:** 

In order to make the malware think it is not within a lab environment we will utilize `inetsim`.

Use the following command to edit the config file for inetsim 

```
sudo [text editor] /etc/inetsim/inetsim.conf
```

Once tweaked to our liking, we can run it with: 

```
sudo inetsim
```

-----------------------------------------

**Applying Patches to Bypass Sandbox Checks:** 

Given if a sample detects it is within a sandbox, it will hinder its execution - we need to defeat these checks. There are several methods: 

Copying the Address from IDA: 

If we pivot back to IDA, we can go back to our assumed main function & pull the address for the `cmp` instruction (must be within text view)

The address is: `00000000004032C8`

Right click on the disassembly view and click go to expression & paste the address to see the `cmp` instruction to implement changes (can also CTRL+G)

Searching Through Strings: 

The first step is to find the string Sandbox detected in the string references & set a breakpoint to stop execution at that point. 

Navigate to string references: 

![x64strings](/Assets/Malware%20Analysis/x64dbg_002_strings_.webp)

In order to find how the jump was made to print the message, we'll set a breakpoint at the last Sandbox detected string.

After setting the breakpoint, double click the string to go to the address where the instructions are located. 

![x64cmp](/Assets/Malware%20Analysis/x64dbg_003_cmp.webp)

As we can see, a `cmp` instruction is seen above the message box which compares the value with 1 after a registry path comparison happens. We'll modify the comparison value to match with 0 instead. 

This is done by placing the cursor over the instruction and pressing spacebar, this allows us to edit the assembly instructions. 

We can change the comparison to `0x0` instead of `0x1`, modifying this could shift the control flow of the code & should not ju











