
Through static analysis we want to find as much information as possible including: 

| File type          |
| ------------------ |
| File hash          |
| Strings            |
| Embedded elements  |
| Packer information |
| Imports            |
| Exports            |
| Assembly code      |

-----------------------------------------

**Identifying File Type:** 

The easiest way to determine the file type is with the `file` command

```shell
file [file path]
```
``
To manually check the header use `hexdump`

```shell
hexdump -C [file path]
```

The presence of an ASCII `MZ (4D 5A)` is the magic number for an executable file

-----------------------------------------

Fingerprinting: 

We want to create a unique identifier (hash) for our sample . To do this use the `[hash type]sum` command. 

For MD5: 

```shell
md5sum [file path]
```

For SHA1: 

```shell
sha1sum [filepath]
```

For SHA256: 

```shell
sha256sum [file path]
```

To lookup a hash, run it through VirusTotal and see if it hits. 

	Hashes aren't always useful for determining if a sample is malicious, as malware authors can change the hash by making slight modifications to the code. 

Import Hashing (IMPHASH): 

This hash is derived from the import functions of a PE. It functions by converting all imported function names to lowercase. Next, the DLL names and function names are fused together and arranged alphabetically. An MD5 hash is generated from the resulting string. This to say, two PEs with identical import functions will share the same IMPHASH. 

The pefile module on Python is perfect to calculate the IMPHASH value. 

```python
import sys
import pefile
import peutils

pe_file = sys.argv[1]
pe = pefile.PE(pe_file)
imphash = pe.get_imphash()

print(imphash)
```

Fuzzy Hashing (SSDEEP): 

Also called context-triggered piecewise hashing (CTPH) is a technique designed to compute the hash value based on similarity between two files. It works by slicing the file into smaller fixed size blocks and then calculates the hash for each block. The values are then meshed together to calculate the final fuzzy hash. 

The SSDEEP algorithm allocates more weight to longer sequences of common blocks, which makes it very effective at identifying files that have minor modifications/are similar but not identical.

To calculate the SSDEEP hash use the `ssdeep` command

```shell
ssdeep [file path]
```

It can also use `-pb` to match files that are in the directory where the samples are, it will show how similar they are as well. 

```shell
ssdeep -pb *
```

Section Hashing: 

Allows for a method to determine sections of a PE that have been modified, very useful for identifying variations in malware. 

It works by calculating the hash of each section. When comparing two PEs, if the hash of the sections in the two files match, it suggests that the particular section has not been modified between the two versions of the file. 

To perform section hashing, the Python pefile module is again useful 

```python
import sys
import pefile
pe_file = sys.argv[1]
pe = pefile.PE(pe_file)
for section in pe.sections:
	print (section.Name, "MD5 hash:", section.get_hash_md5())
	print (section.Name, "SHA256 hash:",  section.get_hash_sha256())
```

	While section hashing is a good way to determine if files are modified - authors can employ tactics like obfuscating the section name or dynamically generating them.

-----------------------------------------

**String Analysis:** 

To provide some insight during investigation, its good to look at strings to see what may be there. Sometimes you can even find unique embedded strings like these: 

| Embedded filenames (e.g., dropped files)                        |
| --------------------------------------------------------------- |
| IP addresses or domain names                                    |
| Registry paths or keys                                          |
| Windows API functions                                           |
| Command-line arguments                                          |
| Unique information that might hint at a particular threat actor |

To see strings, use the `strings` command, if you want to see a string with a certain number of characters use `-n` followed by the number.

```shell
strings [file path]
```

	Sometimes strings can provide a link to who made it, i.e. program databse (PDB) paths

You can also use `floss` (FireEye Labs Obfuscated Strings Solver) to automatically deobfuscate strings and find things that `strings` missed. 

```shell
floss [file path]
```

-----------------------------------------

**Unpacking Packed Malware:** 

Refers to the obfuscation/compression of a sample to defeat analysis techniques (strings analysis, PE sections, code analysis)

A quite popular packer is Ultimate Packer for Executables (UPX)

If a PE is packed with UPX, you can use the `upx` command with `-d -o` to unpack it. 

```shell
upx -d -o [outfile] [original file]
```

