
Through static analysis we want to find as much information as possible including: 

| File type          |
| ------------------ |
| File hash          |
| Strings            |
| Embedded elements  |
| Packer information |
| Imports            |
| Exports            |
| Assembly code      |

-----------------------------------------

**Identifying File Type:** 

The easiest way to determine the file type is with the `file` command

```shell
file [file path]
```
``
To manually check the header use `hexdump`

```shell
hexdump -C [file path]
```

The presence of an ASCII `MZ` is the magic number for an executable file

-----------------------------------------

Fingerprinting: 

We want to create a unique identifier (hash) for our sample . To do this use the `[hash type]sum` command. 

For MD5: 

```shell
md5sum [file path]
```

For SHA1: 

```shell
sha1sum [filepath]
```

For SHA256: 

```shell
sha256sum [file path]
```

To lookup a hash, run it through VirusTotal and see if it hits. 

	Hashes aren't always useful for determining if a sample is malicious, as malware authors can change the hash by making slight modifications to the code. 

Import Hashing (IMPHASH): 

This hash is derived from the import functions of a PE. It functions by converting all imported function names to lowercase. Next, the DLL names and function names are fused together and arranged alphabetically. An MD5 hash is generated from the resulting string. This to say, two PEs with identical import functions will share the same IMPHASH. 

The pefile module on Python is perfect to calculate the IMPHASH value. 

```python
import sys
import pefile
import peutils

pe_file = sys.argv[1]
pe = pefile.PE(pe_file)
imphash = 
```