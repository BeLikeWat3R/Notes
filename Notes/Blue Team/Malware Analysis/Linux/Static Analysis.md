
Through static analysis we want to find as much information as possible including: 

| File type          |
| ------------------ |
| File hash          |
| Strings            |
| Embedded elements  |
| Packer information |
| Imports            |
| Exports            |
| Assembly code      |

-----------------------------------------

**Identifying File Type:** 

The easiest way to determine the file type is with the `file` command

```shell
file [file path]
```
``
To manually check the header use `hexdump`

```shell
hexdump -C [file path]
```

The presence of an ASCII `MZ` is the magic number for an executable file

-----------------------------------------

Fingerprinting: 

We want to create a unique identifier (hash) for our sample . To do this use the `[hash type]sum` command. 

For MD5: 

```shell
md5sum [file path]
```

For SHA1: 

```shell
sha1sum [filepath]
```

For SHA256: 

```shell
sha256sum [file path]
```

To lookup a hash, run it through VirusTotal and see if it hits. 

	Hashes aren't always useful for determining if a sample is malicious, as malware authors can change the hash by making slight modifications to the code. 

Import Hashing (IMPHASH): 

This hash is derived from the import functions of a PE. It functions by converting all imported function names to lowercase. Next, the DLL names and function names are fused together and arranged alphabetically. An MD5 hash is generated from the resulting string. This to say, two PEs with identical import functions will share the same IMPHASH. 

The pefile module on Python is perfect to calculate the IMPHASH value. 

```python
import sys
import pefile
import peutils

pe_file = sys.argv[1]
pe = pefile.PE(pe_file)
imphash = pe.get_imphash()

print(imphash)
```

Fuzzy Hashing (SSDEEP): 

Also called context-triggered piecewise hashing (CTPH) is a technique designed to compute the hash value based on similarity between two files. It works by slicing the file into smaller fixed size blocks and then calculates the hash for each block. The values are then meshed together to calculate the final fuzzy hash. 

The SSDEEP algorithm allocates more weight to longer sequences of common blocks, which makes it very effective at identifying files that have minor modifications/are similar but not identical.

To calculate the SSDEEP hash use the `ssdeep` command

```shell
ssdeep [file path]
```

It can also use `-pb` to match files that are in the directory where the samples are, it will show how similar they are as well. 

```shell
ssdeep -pb *
```

Section Hashing: 

Allows for a method to determine sections of a PE that have been modified, very useful for identifying variations in malware. 

It works by calculating the hash of each section. When comparing two PEs, if the hash of the sections in the two files match, it suggests that the particular section has not been modified between the two versions of the file. 

To perform section hashing, the Python pefile module is again useful 

```python
import sys
import pefile
pe_file = sys.argv[1]
pe = pefile.PE(pe_file)
for section in pe.sections:
	print (section.Name, "MD5 hash:", section.get_hash_md5())
	print (section.Name, "SHA256 hash:",  section.get_hash_sha256())
```

	While section hashing is a good way to determine if files are modified - authors can employ tactics like obfuscateing the section name or dynamically generating them.

-----------------------------------------

**String Analysis:** 

